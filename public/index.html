<canvas id="canvas" width="800" height="800" style="border:1px solid black"></canvas>
<script src="../server/server/Map.js"></script>
<script src="../server/server/Player.js"></script>
<script src="../server/server/Party.js"></script>
<script src="./Key.js"></script>
<script>
    (function () {
        var canvas = document.querySelector("#canvas");
        var ctx = canvas.getContext("2d");

        var party = null;

        var id = null;
        var mouse = {x:0, y:0};

        canvas.addEventListener("mousemove", (e) => {
            mouse.x = e.offsetX;
            mouse.y = e.offsetY;
        });


        var ws = new WebSocket("ws://127.0.0.1:54321");

        ws.onopen = function () {
            ws.send(JSON.stringify({
                type: "join",
                name: "Joueur " + Math.floor(Math.random() * 1000)
            }));

            setInterval(() => {
                ws.send(JSON.stringify({
                    type: "ping",
                    datetime: Date.now()
                }))
            }, 1000 * 2);
        }

        ws.onmessage = function (event) {
            var msg = JSON.parse(event.data);

            switch (msg.type) {
                case "ping":
                    // console.log("PING", Date.now() - msg.datetime, "ms");
                    break;
                case "init":
                    party = new Party(msg);
                    var players = [];
                    for (var player of msg.players) {
                    	player.party = party;
                        players.push(new Player(player));
                    }
                    var map = new Map(msg.map);
                    console.log(msg);
                    party.players = players;
                    party.map = map;
                    update();
                    break;

                case "snapshot":
                	var time = Date.now();
                    for (var player of msg.players) {
                        for (var p of party.players) {
                            if (p.id == player.id) {
                            	player.time = time;
                            	p.positions.push(player);
                                break;
                            }
                        }
                    }
                    break;

                case "new_player":
                    party.addPlayer(new Player(msg));
                    break;

                case "remove_player":
                    party.removePlayer({id:msg.id});
                    break;

                case "id":
                    id = msg.id;
                    break;
                default:
                    break;
            }
        }

        var update = function () {
            if(!id) return;

            var tilesize = Math.min(canvas.width/party.map.tiles.length, canvas.height/party.map.tiles[0].length);

            var inputs = {};

            var player = party.getPlayer(id);
            if(!player) return;
            inputs.direction = Math.atan2(mouse.y - player.y * tilesize, mouse.x - player.x * tilesize);
            
            if(KeyManager.isDown("up") || KeyManager.isDown("z") || KeyManager.isDown("w")){
                inputs.u = true;
            }

            if(KeyManager.isDown("down") || KeyManager.isDown("s")){
                inputs.d = true;
            }

            if(KeyManager.isDown("left") || KeyManager.isDown("q") || KeyManager.isDown("a")){
                inputs.l = true;
            }

            if(KeyManager.isDown("right") || KeyManager.isDown("d")){
                inputs.r = true;
            }	

            inputs.id = player.nbInput;
            player.nbInput++;
            player.addInputs(inputs);
            player.update();
            ws.send(JSON.stringify({type:"inputs", inputs:inputs}));

            setTimeout(() => {
                update();
            }, 1000/party.config.physic);
        }

        var render = function () {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (!party) {
                requestAnimationFrame(render);
                return;
            }
            var tilesize = Math.min(canvas.width/party.map.tiles.length, canvas.height/party.map.tiles[0].length);

            //map
            for(var i in party.map.tiles){
                for(var j in party.map.tiles[i]){
                    if(party.map.tiles[i][j]){
                        ctx.fillRect(i * tilesize, j * tilesize, tilesize, tilesize);
                    }
                    ctx.strokeRect(i * tilesize, j * tilesize, tilesize, tilesize);
                }
            }
            var interp = Date.now() - (1000/party.config.snapshot) * 1.5;

            //players
            for (var player of party.players) {
            	player.interpolate(interp);
                ctx.beginPath();
                ctx.arc(player.x * tilesize, player.y * tilesize, player.radius * tilesize, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(player.x * tilesize, player.y * tilesize);
                ctx.lineTo(player.x * tilesize + Math.cos(player.direction) * 1.5 * player.radius * tilesize, player.y * tilesize + Math.sin(
                    player.direction) * 1.5 * player.radius * tilesize)
                ctx.stroke();
                ctx.font = "24px Arial";
                ctx.textAlign = "center";
                ctx.fillText(player.name, player.x * tilesize, player.y * tilesize - player.radius * 2 - 24);
            }
            requestAnimationFrame(render);
        }
        requestAnimationFrame(render);
    })();
</script>